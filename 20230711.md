### vue 对比 react

- 相同点
  - 都是组件化思想
  - 都有虚拟dom
  - 都支持服务端渲染
- 不同点
  - react 单项数据流（MVC），vue 双向数据流（MVVM）
  - react 不可变数据，vue 可变数据
  - react 通过回调函数来进行通信，vue 通过 props 和 emit 来进行通信
  - react中事件是通过事件委托来实现的
  - diff 算法不同

### vue2 vs vue3

- 更好的tree-shaking,打包后体积更小,对ts支持更好
- 更接近原生
- 从options api 到 composition api
- vue2采用的是`defineProperty`来实现响应式，vue3采用的是`proxy`
- proxy 解决 数组和对象的响应式问题

### ES6
- set  map
  - set 无序不重复的集合 add() delete() has() clear()
  - map 键值对集合 map.set('foo', true) get() has() delete() clear()
- Promise  用于解决异步编程  将嵌套调用改为链式调用
  - 三种状态 pending fulfilled rejected
- Generator  生成器函数  用于异步编程
  - 通过`yield`关键字将函数分割成多段，每次调用`next()`方法执行一段代码
  - redux-saga 用的就是 generator
- 闭包  （一个函数调用返回一个函数）
  - 创建私有变量
  - 延长变量的声明周期
- 原型链
  - 通过`__proto__`属性来访问原型对象
  - 通过`prototype`属性来访问原型对象
  - 通过`constructor`属性来访问构造函数
![Alt text](image.png)
- this
  - 优先级 new > 显示 > 隐式 > 默认
  - 修改this
    - applay 参数(指向，数组)
    - call 参数(指向，参数1，参数2，...)
    - bind 参数(指向，参数1，参数2，...)  但是不会立即执行
- 垃圾回收机制
  - 标记清除  维护一张表，记录哪些变量不再使用，然后回收它们的内存
  - 引用计数  当一个变量的引用次数为0时，就会被回收
- 本地存储
  - cookie 大小 4kb  用于存储少量数据，每次请求都会携带
  - localStorage 大小 5M  用于存储大量数据，不会携带
  - sessionStorage 大小 5M  用于存储大量数据，会话结束后清除
- 攻击方式
  - XSS 跨站脚本攻击 通过输入框等注入恶意脚本，获取用户信息
    - 一般框架都已经做了转义处理
  - CSRF 跨站请求伪造 通过伪造用户请求，进行恶意操作
    - 弃用cookie，使用JWT
- 回流 与 重绘
  - 回流：当页面布局和几何属性发生变化时，浏览器会重新渲染页面，称为回流
  - 重绘：当页面元素的绘制属性发生变化时，浏览器会重新渲染页面，称为重绘
  - 优化：
    - 尽量减少多次操作DOM 合并操作
    - 样式也是  如果样式较多 可以通过添加类名来一次性实现
- 响应式布局
  - 媒体查询  百分比 rem  vw/vh
- 垂直水平居中
  - flex  justify-content: center; align-items: center;
  - position  top: 50%; left: 50%; transform: translate(-50%, -50%);
  - position  top: 0 ; left: 0; right: 0; bottom: 0; margin: auto;
- css 优化
  - 异步加载css 
  - 资源压缩
  - 避免使用@import  因为 它会将多个css文件合并成一个
- 文字溢出 省略号
  - 单行  overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
  - 多行  display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 3; overflow: hidden;
### webpack
- loader 与 plugin 区别
  - loader 用于对模块的源代码进行转换
  - plugin 用于扩展webpack的功能

### HTTP
- http 与 https 区别
 - https 更加安全，但性能不如 http，因为 https 需要加密解密以及多次握手
 - http 明文传输，https 加密传输
 - 二者使用的端口不同，http 80，https 443
- GET 与 POST 区别
  - GET 一般用于获取数据，POST 一般用于提交数据
  - GET 请求参数会显示在url上，POST 请求参数不会显示在url上
  - GET 请求参数有长度限制，POST 请求参数没有长度限制
- 从输入URL到浏览器渲染过程
  - DNS解析
  - 建立TCP连接
  - 发起HTTP请求
  - 服务器处理请求并返回HTTP报文
  - 浏览器解析渲染页面
  - 连接结束
- TCP 三次握手
  - 第一次 客户端发起
  - 第二次 服务端接收并发起  服务端确认收到
  - 第三次 客户端接收并发起  客户端确认收到
- TCP 四次挥手
  - 第一次 客户端 请求断开
  - 第二次 服务端接收并发起  服务端确认收到
  - 第三次 服务端 请求断开
  - 第四次 客户端接收并发起  客户端确认收到
### SPA single-page-application 单页面应用

- SPA  vs  MPA
  - SPA
    - 优点
      - 用户体验好，快，内容的改变不需要重新加载整个页面
      - 前后端分离，架构清晰，前端进行交互逻辑，后端负责数据处理
    - 缺点
      - SEO 难度较高
      - 初次加载耗时多
      - 前进后退路由管理
  - MPA
    - 优点
      - 初次加载快
      - SEO 较好
      - 后退前进管理
    - 缺点
      - 用户体验差，每次跳转都需要重新加载页面
      - 前后端耦合，开发效率低

### Vue

- 组件内的钩子函数
  - activated // keep-alive 缓存的组件激活时
  - deactivated // keep-alive 缓存的组件停用时调用
  - beforeRouteEnter
  - beforeRouteUpdate  // 例如从 /user/1 导航到 /user/2
  - beforeRouteLeave
- v-for 优先级高于 v-if  // 二者不能同时使用
- data为什么是一个函数
  - 保证每个组件实例都有自己的数据，防止组件之间数据相互影响
- 直接添加属性到实例上，不会触发更新
  - Vue.set( target, propertyName/index, value )
  - Object.assign()  // 拷贝并返回一个新对象
  - $forceUpdate()  // 强制更新
- 组件通信方法
  - `props` `$emit`
  - `ref`
  - `$parent` `$children`
  - `$attrs` `$listeners`
  - `provide` `inject`
  - `eventbus`   vue3已废弃  不利用代码阅读
  - `vuex`
- nextTick
  - 作用：在下次 DOM 更新循环结束之后执行延迟回调，可以理解为 vue更新DOM是异步执行的
- mixin 本质就是一个js对象，可以包含created，mounted等生命周期函数，也可以包含data，methods等选项
  - 优点
    - 可以抽离公共代码，减少重复代码
    - 可以在不同的组件中混入不同的选项
    - 提高代码的复用性
  - 缺点
    - 命名冲突
    - 难以维护
    - 污染全局变量
- slot 插槽
  - 匿名插槽 其实name为default
  - 具名插槽 name='xxx'   v-slot:xxx  #xxx
  - 作用域插槽 v-slot:xxx='props' #xxx="{props}"  // props为传递的数据 
- Vue.observable({ count : 1})
  - 小型的状态管理
- keepAlive
  - 用于组件缓存 一般搭配 router 来使用
  - 可以在配置路由表时 通过 meta 属性来配置缓存
  - 在router-view 获取$route.meta.keepAlive 来判断是否缓存
- 修饰符
  - lazy trim number stop native ...
- 过滤器 filter
  - 一般用来格式化单位，文本格式等  vue3 已废除
- SSR 解决的问题
  - SEO  以及  首屏加载优化
- 权限管理
  - 前端定义路由表，菜单由后端返回  addRoutes
    - 菜单与路由需要一一对应
    - 路由守卫每次都需要判断
  - 菜单和路由都有后端返回
    - 后端在后返回定义好路由组件的名称，前端根据名称去匹配路由表
    - 每次跳转需要判断，前后端配合要求更高
  - 按钮权限
    - 路由表中配置好 那些用户拥有按钮权限
    - 可以通过自定义指令 或者 mixin  混入按钮控制方案
- 双向绑定 mvvm
  - v-model vue2= v-bind:value + v-on:input  vue3= v-model:value + v-onUpdate:value
- key
  - +new Date() 可以做到强制刷新

### vue template

- template编译
  - 创建文档碎片，将模板中的内容一次性添加到文档碎片中
  - 解析模板中的指令和插值表达式，将指令对应的节点以及插值表达式对应的节点进行相应的处理，最终生成虚拟DOM
  - 创建  自更新 的方法 并将其保存到`watcher`中
  - 通过Object.defineProperty()方法将data中的数据转换成getter/setter，并在getter中收集依赖，在setter中触发依赖
  - 当data中的数据被访问时就将这个数据的更新方方法收集到watcher中，当数据被修改时就通知watcher更新视图
- diff 算法
  - 新旧节点从前向后比较，相同更新，不同跳出
  - 新旧节点从后向前比较，相同更新，不同跳出
  - 旧开->新结束
    - 如果不相同

### React
- JSX-->createElement-->虚拟DOM-->真实DOM
  - babel-preset-react-app会将JSX转换成React.createElement()函数调用
  - createElement()函数会返回一个对象，这个对象就是虚拟DOM
  - render()函数会将虚拟DOM转换成真实DOM并渲染到页面中
- diff 算法
  - key和类型相同 更新并复用旧节点
  - key或类型不同 删除旧的，创建新的
  - 如果相同 经历两轮比较
  - 第一轮 主要处理节点更新 只要key不同，立即退出看是第二轮循环
  - 第二轮 主要是处理节点新增、删除和移动
  - 会从新节点中取节点与老节点中匹配，然后移动位置，并执行增删操作
- 生命周期 
  - componentWillMount 
  - componentDidMount 
  - shouldComponentUpdate
  - componentWillUpdate 
  - componentDidUpdate
  - componentWillReceiveProps 
  - componentWillUnMount
  - 父willMount->父render->子willMount->子render->子didMount->父didMount
- hooks 
  - useEffect(()=>{return{}}, []) 
- 优化相关
  - setState 在 react18中无论在哪里(包括定时器)都是异步操作,减少视图更新的次数 
  - PureComponent 它会自动给类组件添加一个shouldComponentUpdate方法 
  - 内部会自动对那个对新旧数据进行一个潜比较，如果没改变就不重新渲染视图 
  - memo 包裹函数组件能达到同样效果
  - 如果使用useState hooks它内部就实现了潜比较 
- 组件通信 
  - createContext 
- redux 流程 
  - 首先创建store 将reducer传递进入 
  - 通过react-redux 提供的Provider将store挂载到全局 
  - 定义actions
  - 使用： 通过钩子函数useSelector来获取state,useDispatch来触发事件

#### 首屏加载优化  First Contentful Paint

- 优化方案
  - 减小入口文件体积  路由懒加载
  - 本地缓存静态资源  采用HTTP缓存，设置Cache-Control，Last-Modified，Etag等响应头
  - UI框架按需加载 tree shaking
  - 图片资源压缩
  - 开启gzip压缩
  - 服务端渲染SSR

polyfill 用于实现浏览器不支持原生功能的代码 // 例如：babel-polyfill