### vue 对比 react

- 相同点
  - 都是组件化思想
  - 都有虚拟dom
  - 都支持服务端渲染
- 不同点
  - react 单项数据流（MVC），vue 双向数据流（MVVM）
  - react 不可变数据，vue 可变数据
  - react 通过回调函数来进行通信，vue 通过 props 和 emit 来进行通信
  - diff 算法不同

### vue2 vs vue3

- 更好的tree-shaking,打包后体积更小,对ts支持更好
- 更接近原生
- 从options api 到 composition api
- vue2采用的是`defineProperty`来实现响应式，vue3采用的是`proxy`
- proxy 解决 数组和对象的响应式问题

### ES6
- set  map
  - set 无序不重复的集合 add() delete() has() clear()
  - map 键值对集合 map.set('foo', true) get() has() delete() clear()
- Promise  用于解决异步编程  将嵌套调用改为链式调用
  - 三种状态 pending fulfilled rejected
- Generator  生成器函数  用于异步编程
  - 通过`yield`关键字将函数分割成多段，每次调用`next()`方法执行一段代码
  - redux-saga 用的就是 generator
- 闭包  （一个函数调用返回一个函数）
  - 创建私有变量
  - 延长变量的声明周期
- 原型链
  - 通过`__proto__`属性来访问原型对象
  - 通过`prototype`属性来访问原型对象
  - 通过`constructor`属性来访问构造函数
![Alt text](image.png)
- this
  - 优先级 new > 显示 > 隐式 > 默认
  - 修改this
    - applay 参数(指向，数组)
    - call 参数(指向，参数1，参数2，...)
    - bind 参数(指向，参数1，参数2，...)  但是不会立即执行
- 垃圾回收机制
  - 标记清除  维护一张表，记录哪些变量不再使用，然后回收它们的内存
  - 引用计数  当一个变量的引用次数为0时，就会被回收
- 本地存储
  - cookie 大小 4kb  用于存储少量数据，每次请求都会携带
  - localStorage 大小 5M  用于存储大量数据，不会携带
  - sessionStorage 大小 5M  用于存储大量数据，会话结束后清除
- 攻击方式
  - XSS 跨站脚本攻击 通过输入框等注入恶意脚本，获取用户信息
    - 一般框架都已经做了转义处理
  - CSRF 跨站请求伪造 通过伪造用户请求，进行恶意操作
    - 弃用cookie，使用JWT
- 回流 与 重绘
  - 回流：当页面布局和几何属性发生变化时，浏览器会重新渲染页面，称为回流
  - 重绘：当页面元素的绘制属性发生变化时，浏览器会重新渲染页面，称为重绘
  - 优化：
    - 尽量减少多次操作DOM 合并操作
    - 样式也是  如果样式较多 可以通过添加类名来一次性实现
- 响应式布局
  - 媒体查询  百分比 rem  vw/vh

### webpack
- loader 与 plugin 区别
  - loader 用于对模块的源代码进行转换
  - plugin 用于扩展webpack的功能

### SPA single-page-application 单页面应用

- SPA  vs  MPA
  - SPA
    - 优点
      - 用户体验好，快，内容的改变不需要重新加载整个页面
      - 前后端分离，架构清晰，前端进行交互逻辑，后端负责数据处理
    - 缺点
      - SEO 难度较高
      - 初次加载耗时多
      - 前进后退路由管理
  - MPA
    - 优点
      - 初次加载快
      - SEO 较好
      - 后退前进管理
    - 缺点
      - 用户体验差，每次跳转都需要重新加载页面
      - 前后端耦合，开发效率低

### Vue

- 组件内的钩子函数
  - activated // keep-alive 缓存的组件激活时
  - deactivated // keep-alive 缓存的组件停用时调用
  - beforeRouteEnter
  - beforeRouteUpdate  // 例如从 /user/1 导航到 /user/2
  - beforeRouteLeave
- v-for 优先级高于 v-if  // 二者不能同时使用
- data为什么是一个函数
  - 保证每个组件实例都有自己的数据，防止组件之间数据相互影响
- 直接添加属性到实例上，不会触发更新
  - Vue.set( target, propertyName/index, value )
  - Object.assign()  // 拷贝并返回一个新对象
  - $forceUpdate()  // 强制更新
- 组件通信方法
  - `props` `$emit`
  - `ref`
  - `$parent` `$children`
  - `$attrs` `$listeners`
  - `provide` `inject`
  - `eventbus`   vue3已废弃  不利用代码阅读
  - `vuex`
- nextTick
  - 作用：在下次 DOM 更新循环结束之后执行延迟回调，可以理解为 vue更新DOM是异步执行的
- mixin 本质就是一个js对象，可以包含created，mounted等生命周期函数，也可以包含data，methods等选项
  - 优点
    - 可以抽离公共代码，减少重复代码
    - 可以在不同的组件中混入不同的选项
    - 提高代码的复用性
  - 缺点
    - 命名冲突
    - 难以维护
    - 污染全局变量
- slot 插槽
  - 匿名插槽 其实name为default
  - 具名插槽 name='xxx'   v-slot:xxx  #xxx
  - 作用域插槽 v-slot:xxx='props' #xxx="{props}"  // props为传递的数据 
- Vue.observable({ count : 1})
  - 小型的状态管理
- keepAlive
  - 用于组件缓存 一般搭配 router 来使用
  - 可以在配置路由表时 通过 meta 属性来配置缓存
  - 在router-view 获取$route.meta.keepAlive 来判断是否缓存
- 修饰符
  - lazy trim number stop native ...
- 过滤器 filter
  - 一般用来格式化单位，文本格式等  vue3 已废除
- SSR 解决的问题
  - SEO  以及  首屏加载优化
- 权限管理
  - 前端定义路由表，菜单由后端返回  addRoutes
    - 菜单与路由需要一一对应
    - 路由守卫每次都需要判断
  - 菜单和路由都有后端返回
    - 后端在后返回定义好路由组件的名称，前端根据名称去匹配路由表
    - 每次跳转需要判断，前后端配合要求更高
  - 按钮权限
    - 路由表中配置好 那些用户拥有按钮权限
    - 可以通过自定义指令 或者 mixin  混入按钮控制方案
- 双向绑定 mvvm
  - v-model vue2= v-bind:value + v-on:input  vue3= v-model:value + v-onUpdate:value
- key
  - +new Date() 可以做到强制刷新


#### 首屏加载优化  First Contentful Paint

- 优化方案
  - 减小入口文件体积  路由懒加载
  - 本地缓存静态资源  采用HTTP缓存，设置Cache-Control，Last-Modified，Etag等响应头
  - UI框架按需加载 tree shaking
  - 图片资源压缩
  - 开启gzip压缩
  - 服务端渲染SSR



polyfill 用于实现浏览器不支持原生功能的代码 // 例如：babel-polyfill